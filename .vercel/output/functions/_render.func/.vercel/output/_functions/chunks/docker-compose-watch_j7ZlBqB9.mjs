const id = "docker-compose-watch.md";
						const collection = "blog";
						const slug = "docker-compose-watch";
						const body = "My favorite use case for *Docker* is to spin up a local database for development purposes.\r\nTaking this a step further, it is possible to run all neccessary components of your application with a single *Docker Compose* configuration.\r\nUntil recently, this has been a painful method of doing development since any code changes would require a full restart to take effect. \r\n\r\nInstroduced in a recent update, `docker compose watch` allows *Docker Compose* services to monitor certain code paths and update as you edit and save code.\r\nIn this article I will show you how to set up a project using *Next.js* and *PostgreSQL* that can be spun up locally using this command.\r\n\r\n## Creating the Next.js App\r\n\r\nTo create our *Next.js* app simply run:\r\n```bash\r\nnpx create-next-app@latest\r\n```\r\nFrom there, follow the instructions in the terminal to select which components to include. I recommend the default options, *TypeScript*, *ESLint*, *app directory*, etc.\r\n\r\nAfter everything finishes downloading we should be able to run our application in development mode using `npm run dev`. But we want to run this app using *Docker* so lets create a *Dockerfile*:\r\n```bash\r\ntouch Dockerfile\r\n```\r\nInspired by [Next.js's dev Dockerfile example](https://github.com/vercel/next.js/blob/canary/examples/with-docker-compose/next-app/dev.Dockerfile), let's write instructions to copy the source code over to the container's /app directory, install the necessary dependencies and run the application in development mode:\r\n```dockerfile\r\nFROM node:alpine\r\n\r\nRUN mkdir -p /app\r\nWORKDIR /app\r\nCOPY package*.json /app\r\nRUN npm install\r\nCOPY . /app\r\nEXPOSE 3000\r\n\r\nCMD [\"npm\", \"run\", \"dev\"]\r\n```\r\nAt this point we have a runnable docker container for our app. Let's get started with our *docker-compose.yaml* and add a profile for this app.\r\n```bash\r\ntouch docker-compose.yaml\r\n```\r\n```yaml\r\nversion: \"3\"\r\nservices:\r\n  next-app:\r\n    container_name: next-app\r\n    build:\r\n      dockerfile: Dockerfile\r\n    volumes:\r\n      - ./src:/app/src\r\n      - ./public:/app/public\r\n    restart: always\r\n    ports:\r\n      - 3000:3000\r\n```\r\nNow our app can be run by running `docker compose up`.\r\n\r\n## Creating the Postgres Database\r\n\r\nLet's create a local database using the official [Postgres Docker image](https://hub.docker.com/_/postgres).\r\nWe can do this by appending the following to our *docker-compose.yaml*:\r\n```yaml\r\n  postgres-db:\r\n    image: postgres:16.0\r\n    container_name: postgres-db\r\n    restart: always\r\n    environment:\r\n      POSTGRES_DB: example\r\n      POSTGRES_USER: root\r\n      POSTGRES_PASSWORD: 123\r\n    ports:\r\n      - 5432:5432\r\n```\r\nNow `docker compose up` additionally spins up a local database which we can connect to by adding the following connection string to a *.env* file in the root of our *Next.js* project:\r\n```bash\r\nPOSTGRES_URL=\"postgres://root:123@localhost:5432/example\"\r\n```\r\nWe currently have no way of testing our database through our *Next.js* app but we can verify that the database is running by executing `psql example` through *Docker Desktop*:\r\n![Docker Desktop](/assets/docker-desktop-psql.png)\r\n\r\n## Populating the Database\r\nTo interact with our database from our *Next.js* app we need an ORM tool. Let's install my favorite database ORM *drizzle-orm*:\r\n```bash\r\nnpm install drizzle-orm postgres pg\r\nnpm install -D drizzle-kit\r\n```\r\nNow let's set up our first table using *drizzle-orm* by loosely following the [official quick start example](https://orm.drizzle.team/kit-docs/quick):\r\n\r\n1. Create our first schema:\r\n\r\n```bash\r\ntouch src/schema/post.ts\r\n```\r\n```typescript\r\nimport { serial, text, timestamp, pgTable } from \"drizzle-orm/pg-core\";\r\n\r\nexport const post = pgTable(\"post\", {\r\n  id: serial(\"id\"),\r\n  text: text(\"text\"),\r\n  createdAt: timestamp(\"created_at\").default(new Date()),\r\n});\r\n```\r\n\r\n2. Create our *drizzle* configuration:\r\n\r\n```bash\r\ntouch drizzle.config.ts\r\n```\r\n```typescript\r\nimport type { Config } from \"drizzle-kit\";\r\n\r\nexport default {\r\n  schema: \"./src/schemas/*.ts\",\r\n  out: \"./src/migrations\",\r\n  driver: \"pg\",\r\n  dbCredentials: {\r\n    connectionString: process.env.POSTGRES_URL!,\r\n  },\r\n} satisfies Config;\r\n```\r\n\r\n3. Create our first migration:\r\n\r\n```bash\r\nnpx drizzle-kit generate:pg\r\n```\r\nThis will create a migration file under *src/migrations*.\r\n\r\n4. Apply our migration:\r\n\r\nFirst let's install some necessary dev dependencies:\r\n```bash\r\nnpm install -D dotenv tsx\r\n```\r\n\r\nThen we can create a migration script:\r\n```bash\r\ntouch src/scripts/migrate.ts\r\n```\r\n```typescript\r\nimport postgres from \"postgres\";\r\nimport { migrate } from \"drizzle-orm/postgres-js/migrator\";\r\nimport { drizzle } from \"drizzle-orm/postgres-js\";\r\nimport dotenv from \"dotenv\";\r\n\r\ndotenv.config();\r\n\r\n(async () => {\r\n  const connectionString = process.env.POSTGRES_URL!;\r\n\r\n  const migrationsClient = postgres(connectionString, { max: 1 });\r\n  const db = drizzle(migrationsClient);\r\n\r\n  await migrate(db, { migrationsFolder: \"./src/migrations\" });\r\n\r\n  await migrationsClient.end();\r\n})();\r\n```\r\nNow we can apply our migration by running the script like so:\r\n```bash\r\nnpx tsx src/scripts/migration.tsx\r\n```\r\n\r\nFinally we can populate our database using *Drizzle Studio*:\r\n```bash\r\nnpx drizzle-kit studio\r\n```\r\n![Drizzle Studio](/assets/drizzle-studio.png)\r\n\r\n## Connecting to the Database\r\n\r\nNow that we have a database up-and-running with data, let's display it in our *Next.js* app!\r\nTo do that we must first create a database client:\r\n\r\n```bash\r\ntouch src/db.ts\r\n```\r\n```typescript\r\nimport { drizzle, type PostgresJsDatabase } from \"drizzle-orm/postgres-js\";\r\nimport postgres from \"postgres\";\r\n\r\n// Fix for \"sorry, too many clients already\"\r\ndeclare global {\r\n  // eslint-disable-next-line no-var -- only var works here\r\n  var db: PostgresJsDatabase | undefined;\r\n}\r\n\r\nlet db: PostgresJsDatabase;\r\n\r\nif (process.env.NODE_ENV === \"production\") {\r\n  db = drizzle(postgres(process.env.POSTGRES_URL!));\r\n} else {\r\n  if (!global.db) global.db = drizzle(postgres(process.env.POSTGRES_URL!));\r\n\r\n  db = global.db;\r\n}\r\n\r\nexport { db };\r\n```\r\nUsing this client, let's display the text from our first post entry by replacing the contents of *src/app/page.tsx* with the following:\r\n```tsx\r\nimport { db } from \"@/db\";\r\nimport { post } from \"@/schemas/post\";\r\nimport styles from \"./page.module.css\";\r\n\r\nexport default async function Home() {\r\n  const posts = await db.select().from(post);\r\n\r\n  return <main className={styles.main}>{posts[0].text}</main>;\r\n}\r\n```\r\nIf we run our *Next.js* app locally we should see a black screen with the text \"Hello World\".\r\nBut if we run this using *Docker Compose* we will get an error because our *Next.js* container is unable to connect to our *Postgres* container.\r\nThis is because our connection string uses localhost but for docker containers to connect to one another they must use the appropriate *Docker Compose* service name.\r\n\r\nLet's fix this by adding the following line to our *.env* file:\r\n```bash\r\nDOCKER_POSTGRES_URL=\"postgres://root:123@postgres-db:5432/example\"\r\n```\r\nAnd let's tell *Docker Compose* to replace *POSTGRES_URL* with *DOCKER_POSTGRES_URL* by adding the following to our *docker-compose.yaml*'s next-app section:\r\n```yaml\r\nenvironment:\r\n  POSTGRES_URL: ${DOCKER_POSTGRES_URL}\r\n```\r\nIf we run `docker compose up` now, we should see our text displaying correctly.\r\nBut if we save any additional changes while the app is running, our app does not update...\r\n\r\n## Enabling Docker Compose Watch\r\n\r\nTo leverage the hot-module reloading capabilities of `docker compose watch` we must define watch actions in our *docker-compose.yaml* to tell *Docker Compose* to sync our code when we save it.\r\nTo do this, replace our previously defined volumes with appropriate sync actions so that the final *docker-compose.yaml* file looks like this:\r\n```yaml\r\nversion: \"3\"\r\nservices:\r\n  next-app:\r\n    container_name: next-app\r\n    restart: always\r\n    build:\r\n      dockerfile: Dockerfile\r\n    environment:\r\n      POSTGRES_URL: ${DOCKER_POSTGRES_URL}\r\n    develop:\r\n      watch:\r\n        - action: sync\r\n          path: ./src\r\n          target: /app/src\r\n          ignore:\r\n            - node_modules/\r\n        - action: sync\r\n          path: ./public\r\n          target: /app/public\r\n    ports:\r\n      - 3000:3000\r\n  postgres-db:\r\n    image: postgres:16.0\r\n    container_name: postgres-db\r\n    restart: always\r\n    environment:\r\n      POSTGRES_DB: example\r\n      POSTGRES_USER: root\r\n      POSTGRES_PASSWORD: 123\r\n    ports:\r\n      - 5432:5432\r\n```\r\nNow we can finally run `docker compose watch` to have our 2 containers run and respond to changes!\r\n\r\nAnd as our application grows in complexity we can add additional services to our *Docker Compose* configuration and enjoy the amazing DX benefits of `docker compose watch`.\r\n\r\nThe source code for this project is available on [github](https://github.com/kalmanodds/docker-compose-watch-example).\r\n\r\n## Caveats\r\n\r\n`docker compose watch` does not print container output to the console like `docker compose up`.\r\nTo remedy this, we must attach to the containers in a separate terminal session or inspect the output via Docker Desktop.\r\n\r\nThis new feature also lacks many common option paramters, so running `docker compose watch` in detached mode, for example, does not work.";
						const data = {author:"Sigur√∞ur Kalman Oddsson",publishedAt:new Date(1708796100000),title:"Full-Stack Development With Docker Compose Watch",postSlug:"docker-compose-watch",featured:true,draft:false,tags:["docker","nextjs","postgres"],ogImage:"",description:"An introduction to `docker compose watch` and a tutorial on how to spin up a full-stack environment with this single command.",type:"post"};
						const _internal = {
							type: 'content',
							filePath: "C:/Users/sigur/Documents/dev/astro-blog/src/content/blog/docker-compose-watch.md",
							rawData: undefined,
						};

export { _internal, body, collection, data, id, slug };
